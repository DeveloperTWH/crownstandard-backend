---

ğŸ—ï¸ CROWNSTANDARD â€” COMPLETE BACKEND MODEL ARCHITECTURE

---

 1. ğŸ‘¤ User

Purpose: Stores all platform users (Admin, Provider, Customer) in a single collection.

Key Fields:

* name, email, phone, passwordHash
* role (admin | provider | customer)
* status, gender, DOB
* OAuth providers
* providerProfile: approvalStatus, payout info, KYC, earnings, blockedDates, avgRating
* customerProfile: defaultAddress, savedAddresses

Relationships:

* ğŸ”— Referenced in almost every other model
* Service.providerId â†’ User._id
* Booking.customerId / Booking.providerId â†’ User._id
* Review.customerId / Review.providerId â†’ User._id
* PaymentTransaction.customerId / providerId â†’ User._id

---

 2. ğŸ·ï¸ ServiceCategory

Purpose: Categorizes cleaning services (e.g., Home, Office, Carpet, etc.)

Key Fields:

* name, slug, description, active

Relationships:

* Service.categoryId â†’ ServiceCategory._id
* Booking.categoryId â†’ ServiceCategory._id

---

 3. ğŸ§¹ Service

Purpose: Represents a cleaning service listed by a provider.

Key Fields:

* providerId (User)
* categoryId (ServiceCategory)
* title, description
* basePrice, currency, priceUnit, minHours
* includes, exclusions
* media (S3 URLs)
* isActive (provider), isVisible (admin)
* ratingSummary

Relationships:

* Booking.serviceId â†’ Service._id
* Review.serviceId â†’ Service._id

---

 4. ğŸ“… Booking

Purpose: Core transaction unit â€” links customer, provider, service, and payment.

Key Fields:

* customerId, providerId, serviceId, categoryId
* status (pending_payment, accepted, completed, etc.)
* scheduledAt, durationHours
* photos (S3 URLs + metadata)
* serviceAddress (snapshot)
* pricingSnapshot (with currency)
* cancellationPolicySnapshot
* payment, payout details
* tipSummary (with currency)
* completionOtp (verification)
* lifecycle timestamps (acceptedAt, completedAt, etc.)

Relationships:

* Booking.customerId â†’ User._id
* Booking.providerId â†’ User._id
* Booking.serviceId â†’ Service._id
* PaymentTransaction.bookingId â†’ Booking._id
* TipTransaction.bookingId â†’ Booking._id
* Review.bookingId â†’ Booking._id
* Dispute.bookingId â†’ Booking._id
* Notification.bookingId â†’ Booking._id

---

 5. ğŸ’³ PaymentTransaction

Purpose: Stores actual payment event for a booking.

Key Fields:

* bookingId, customerId, providerId
* paymentIntentId, chargeId, transferId
* amount, currency, applicationFee, transferAmount
* status, refundedAmount, refundedAt
* payoutStatus, payoutReleasedAt, holdReason
* metadata

Relationships:

* PaymentTransaction.bookingId â†’ Booking._id
* Dispute.paymentTransactionId â†’ PaymentTransaction._id
* AuditLog.targetId â†’ PaymentTransaction._id

---

 6. ğŸ’² TipTransaction

Purpose: Handles tip payment (separate Stripe PaymentIntent).

Key Fields:

* bookingId, customerId, providerId
* paymentIntentId, chargeId
* amount, currency
* status, refundedAmount, refundedAt
* payoutStatus, payoutReleasedAt, holdReason

Relationships:

* TipTransaction.bookingId â†’ Booking._id
* Dispute.tipTransactionId â†’ TipTransaction._id

---

 7. â­ Review

Purpose: Customer feedback on a service.

Key Fields:

* bookingId, serviceId, providerId, customerId
* rating, title, comment, photos
* isVisible

Relationships:

* Review.bookingId â†’ Booking._id
* Review.serviceId â†’ Service._id
* Review.providerId â†’ User._id

---

 8. âš–ï¸ Dispute

Purpose: Tracks complaints, holds, refunds, and resolution outcomes.

Key Fields:

* bookingId, customerId, providerId
* paymentTransactionId, tipTransactionId
* reason, description
* evidence[] (photo/text/chat)
* status (open, under_review, resolved, etc.)
* decision (outcome, refundAmount, notes)
* resolvedBy, resolvedAt

Relationships:

* Dispute.bookingId â†’ Booking._id
* Dispute.paymentTransactionId â†’ PaymentTransaction._id
* Dispute.tipTransactionId â†’ TipTransaction._id
* AuditLog.targetId â†’ Dispute._id

---

 9. ğŸ”” Notification

Purpose: In-app & push notifications for all user actions.

Key Fields:

* userId, bookingId
* type (booking, payment, dispute, etc.)
* title, message, actionUrl
* isRead, isPushed
* meta (extra data)

Relationships:

* Notification.userId â†’ User._id
* Notification.bookingId â†’ Booking._id

---

 10. ğŸ§¾ AuditLog

Purpose: Records all critical admin/system actions for transparency & compliance.

Key Fields:

* performedBy (admin)
* actionType (REFUND_ISSUED, PAYOUT_HELD, etc.)
* targetType, targetId
* description, before, after, meta, ipAddress

Relationships:

* AuditLog.performedBy â†’ User._id
* AuditLog.targetId â†’ any resource (Booking, PaymentTransaction, Dispute, etc.)

---

ğŸ”— ERD-STYLE RELATIONSHIP SUMMARY


User â”€â”€â”€â”€â”€â”€â”€< Service
User â”€â”€â”€â”€â”€â”€â”€< Booking >â”€â”€â”€â”€â”€â”€ ServiceCategory
User â”€â”€â”€â”€â”€â”€â”€< Booking >â”€â”€â”€â”€â”€â”€ Service
Booking â”€â”€â”€â”€< PaymentTransaction
Booking â”€â”€â”€â”€< TipTransaction
Booking â”€â”€â”€â”€< Review
Booking â”€â”€â”€â”€< Dispute
Booking â”€â”€â”€â”€< Notification
PaymentTransaction â”€â”€â”€â”€< Dispute
TipTransaction â”€â”€â”€â”€â”€â”€â”€â”€< Dispute
Dispute â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€< AuditLog
PaymentTransaction â”€â”€â”€â”€< AuditLog
Booking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€< AuditLog


Legend:

* â”€â”€â”€< = one-to-many (e.g., one user can have many bookings)

---

ğŸ“Š How Data Flows Through the System

1. User creates a Booking â†’ stores pricingSnapshot, photos, and OTP.
2. Booking payment creates a PaymentTransaction.
3. Optional tip creates a TipTransaction.
4. Booking completion allows Review creation.
5. If a problem arises, a Dispute is created â†’ linked to payment/tip.
6. Notifications fire at each stage via Notification.
7. Admin actions (refund, hold, resolve) logged in AuditLog.

---

âœ… Result:
We now have a fully normalized, production-ready MongoDB schema architecture that:

* Covers every critical business flow.
* Scales to thousands of users and bookings.
* Supports future features like subscriptions, promotions, and analytics.
* Is Stripe-ready, dispute-ready, and admin-dashboard-ready.

---

Would you like me to now move on to the API design phase (starting with auth, service, booking, etc.)? â€“ This is the logical next step after schema design.
